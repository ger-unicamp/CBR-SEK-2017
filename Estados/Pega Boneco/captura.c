#pragma config(Sensor, S1,     ult,            sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     ,               sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     giro,           sensorEV3_Gyro)
#pragma config(Motor,  motorA,          dir,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          esq,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          cancela,       tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Definição de estados */
#define RETO 			1
#define INTERSECCAO		2
#define CAPTURAR		3
#define RAMPA_IDA		4
#define PLAZA			5
#define RAMPA_VOLTA		6
#define SEM_SAIDA		7

/* Outras definições */
#define DIST_BONECO		25
#define DIST_ANDAR 23
#define TAM 6
#define POTENCIA 20 // 30

/* Definicoes de direcoes das interseccoes */
#define DIREITA 1
#define FRENTE 2
#define ESQUERDA 3

/* Definicoes para motores */
#define TRAS -1
#define ANTIHORARIO -1 //ESQUERDA
#define HORARIO 1 //DIREITA
#define DESLIGA 0
#define POTENCIA_GIRO 10
//int bonecos_total = 0;

/*Funcao andar reto
** Param: sentido
*/
void AndarReto (int sentido){
	setMotorSync(dir,esq,0,sentido*POTENCIA);
}


/*Funcao para andar x cm
** Param: distancia
*/
void anda_x_cm (float x){
	float angulo;

	angulo = (x*20.835);

	if (angulo >= 0){
		setMotorReversed(dir, false);
		setMotorReversed(esq, false);
		} else {
		setMotorReversed(esq, true);
		setMotorReversed(dir, true);
	}

	moveMotorTarget(dir, angulo, 20);
	moveMotorTarget(esq, angulo, 20);

	waitUntilMotorStop(dir);
	waitUntilMotorStop(esq);

	setMotorReversed(dir, false);
	setMotorReversed(esq, false);

}


/*Funcao para andar x cm
** Param: distancia
*/
void GirarRobo (float x, int sentido){
	float angulo;

	angulo = (x*20.835);

	if (angulo >= 0){
		setMotorReversed(dir, false);
		setMotorReversed(esq, false);
		}else {
		setMotorReversed(esq, true);
		setMotorReversed(dir, true);
	}

	//GIRAR DIREITA
	if(sentido == DIREITA){
		moveMotorTarget(dir, angulo, -20);
		moveMotorTarget(esq, angulo, 20);

		waitUntilMotorStop(dir);
		waitUntilMotorStop(esq);

		setMotorReversed(dir, false);
		setMotorReversed(esq, false);
		}else{
		if(sentido == ESQUERDA){
			moveMotorTarget(dir, angulo, 20);
			moveMotorTarget(esq, angulo, -20);

			waitUntilMotorStop(dir);
			waitUntilMotorStop(esq);

			setMotorReversed(dir, false);
			setMotorReversed(esq, false);
			}else{
			AndarReto(1);
			delay(2000);
		}
	}


}


/* Função para saber se existe boneco a ser recolhido ou não
** Params: nenhum
*/
bool ultrassonico(){
	int vet[11];
	int i;
	int j;
	int aux;
	int k = 10;

	//Lê 11 valores de distância em CM
	for (i=0; i<11; i++){
		vet[i] = getUSDistance(ult);
	}

	//Bubble Sort
	for(i = 0; i < 11; i++){
		for(j = 0; j < k; j++){
			if(vet[j] > vet[j+1]){
				aux = vet[j];
				vet[j] = vet[j+1];
				vet[j+1]=aux;
			}
		}
		k--;
	}

	//Ver se o sensor achou o boneco e retorna true ou false
	if (vet[5] < DIST_BONECO){
		return true;
		}else{
		return false;
	}
}

/*Funcao para pegar boneco
** Param:
*/
void pega_boneco(){
	anda_x_cm (15); //teste para deixar o boneco no centro
	GirarRobo(18,ESQUERDA); //giro (direita)
	setMotorTarget (cancela, 120, 10);
	waitUntilMotorStop (cancela);
	anda_x_cm (DIST_ANDAR);
	setMotorTarget (cancela, 0, 5);
	waitUntilMotorStop (cancela);
	anda_x_cm (-DIST_ANDAR);
	GirarRobo(18,DIREITA);//giro (esquerda);
}

task main(){
	bool ult;
	//resetGyro(S4);

	//int estado = RETO;
	//TLegoColors cor;


	while(true){
		ult = ultrassonico();
		//	cor = getColor(S2);

		if(ult == true){
			pega_boneco();
			}else{
			AndarReto(FRENTE);
		}
	}


}
