#pragma config(Sensor, S1,     ult,            sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     cor,            sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S3,     ,               sensorSONAR)
#pragma config(Motor,  motorA,          dir,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          esq,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          cancela,       tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
**
** Código principal do robô da categoria IEEE SEK 2017
** Baseado em uma máquina de estados dependente de sensores ultrassônico e de cor
** GER - Grupo de Estudos em Robótica
** 09/11/2017
**
*/


/* Definição de estados */
#define RETO 1
#define INTERSECCAO 2
#define CAPTURAR 3 /*Captura apenas um boneco por vez*/
#define RAMPA_IDA 4 /*Mudar a potencia do motor*/
#define PLAZA 5 /*zerar a variavel pega_boneco*/
#define RAMPA_VOLTA 6 /*Verificar a variavel plaza - ao capturar um boneco setar essa variavel e mudar o sentido do robô*/
#define SEM_SAIDA 7

/* Outras definições */
#define DIST_BONECO	25
#define DIST_ANDAR 25
#define DIST_ANDAR_RE 25
#define DIST_TEST_CANCELA 10 /*caso nao consiga abrir a cancela, porque tem boneco na frente, andar para tras 10cm - estado plaza*/
#define TAM 6

/* Definicoes de direcoes das interseccoes */
#define DIREITA 1
#define FRENTE 2
#define ESQUERDA 3

/* Definicoes para motores */
#define TRAS -1
#define DESLIGA 0
#define POTENCIA_GIRO 10
#define POTENCIA_RAMPA_IDA 20
#define POTENCIA_RAMPA_VOLTA 15
#define POTENCIA 20 /*Potencia que o robô consegue andar entre as plataforma*/
#define pos_abrir 180
#define vel_abrir 5
#define pos_fechar 0
#define vel_fechar 15

/* Variaveis globais */
//int sem_saida = 0;
int captura_boneco = 0;
//int estado = RETO;
//int topo;
//bool plaza = false; /* Plaza false -> sentido plaza ; plaza true -> sentid rua*/

/*Funcao andar reto
** Param: sentido
*/
void AndarReto (int sentido){
	setMotorSync(dir,esq,0,sentido*POTENCIA);
}

void funcao_cancela(int posicao, int velocidade){
	displayTextLine(4,"funcao_cancela");

	if(posicao == pos_abrir && velocidade == vel_abrir){
		displayTextLine(3,"cancela sera aberta");
		setMotorTarget (cancela,pos_abrir,vel_abrir); //Abrir cancela
		delay(3000);
	}else{
		displayTextLine(3,"cancela sera fechada");
		setMotorTarget (cancela,pos_fechar,vel_fechar); //Fechar cancela
		delay(3000);
	}

}

/*Funcao para andar x cm
** Param: distancia
*/
void anda_x_cm (float x){
float angulo;

	angulo = (x*17.5);

	if (angulo >= 0){
		setMotorReversed(dir, false);
		setMotorReversed(esq, false);
	} else {
		setMotorReversed(esq, true);
		setMotorReversed(dir, true);
	}

	moveMotorTarget(dir, angulo, 20);
	moveMotorTarget(esq, angulo, 20);

	waitUntilMotorStop(dir);
	waitUntilMotorStop(esq);

	setMotorReversed(dir, false);
	setMotorReversed(esq, false);

}

/*Funcao para pegar boneco
** Param:
*/
void pega_boneco(){
captura_boneco++;

	anda_x_cm (-23); /*teste para deixar o boneco no centro*/
	setMotorTarget (cancela, 190, 8); /*abrir cancela*/
	waitUntilMotorStop (cancela);
	anda_x_cm (26); /*teste para deixar o boneco no centro*/
	delay(500);
	anda_x_cm (-3);
	setMotorTarget (cancela, 0, 15); /*fecha cancela*/
	waitUntilMotorStop (cancela);
	delay(2000);

}

/* Função para saber se existe boneco a ser recolhido ou não
** Params: nenhum
*/
bool ultrassonico(){
	int vet[11];
	int i;
	int j;
	int aux;
	int k = 10;

	/*Lê 11 valores de distância em CM*/
	for (i=0; i<11; i++){
		vet[i] = getUSDistance(ult);
	}

	/*Bubble Sort*/
	for(i = 0; i < 11; i++){
		for(j = 0; j < k; j++){
			if(vet[j] > vet[j+1]){
				aux = vet[j];
				vet[j] = vet[j+1];
				vet[j+1]=aux;
			}
		}
		k--;
	}

	/*Verificar se o sensor achou o boneco e retorna true ou false*/
	if (vet[5] < DIST_BONECO){
		return true;
		}else{
		return false;
	}
}

task main(){
	/*variaveis*/
	bool ult;
	int estado = RETO;

	displayTextLine(1,"INICIO DA TASK MAIN");

	while(true){

		ult = ultrassonico();

		if(ult == true){
			if(captura_boneco == 0){
				estado = CAPTURAR;
			}
		}else{
			estado = RETO;
		}

		switch(estado){
			case 1:
				AndarReto(FRENTE);
			break;

			case 3:
				pega_boneco();
			break;

		}
	}


}
