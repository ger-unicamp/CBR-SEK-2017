#pragma config(Sensor, S1,     ultrassonico,   sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     sensor_cor,     sensorNone)
#pragma config(Motor,  motorA,          dir,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          esq,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          cancela,       tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Definição de estados */
#define RETO 			1
#define INTERSECCAO		2
#define CAPTURAR		3
#define RAMPA_IDA		4
#define PLAZA			5
#define RAMPA_VOLTA		6
#define SEM_SAIDA		7

/* Outras definições */
#define DIST_BONECO		25
#define DIST_ANDAR 20
#define TAM 6
#define POTENCIA 20 // 30

/* Definicoes de direcoes das interseccoes */
#define DIREITA 1
#define FRENTE 2
#define ESQUERDA 3

/* Definicoes para motores */
#define TRAS -1
#define DESLIGA 0
#define POTENCIA_GIRO 10

/* Definicoes de calibracao */
#define CALIBRA_GIRO 3.25
#define CALIBRA_RETO 21.7


void AndarReto (int sentido){
	setMotorSync(dir,esq,0,sentido*POTENCIA);
}

void GirarRobo (float angulo, int sentido){
	float encoder;

	encoder = (angulo*CALIBRA_GIRO);

	//GIRAR DIREITA
	if(sentido == DIREITA){
		setMotorSyncEncoder(dir, esq, -100, encoder, 30);

		waitUntilMotorStop(dir);
		waitUntilMotorStop(esq);

		}else{

		if(sentido == ESQUERDA){
			setMotorSyncEncoder(dir, esq, 100, encoder, 30);

			waitUntilMotorStop(dir);
			waitUntilMotorStop(esq);
		}
	}


}

/* Função para Retornar a Cor lida pelo Sensor
** Params: porta conectada do sensor de cor
*/
TLegoColors getColor(tSensors sensor)
{
	//Creates variables to store the red, green, and blue values
	long int redValue;
	long int greenValue;
	long int blueValue;

	//Get the value of all three channels of the color sensor
	//and store it in the variables
	getColorRGB(sensor, redValue, greenValue, blueValue);
	// se alguma COR for detectada
	if((redValue != 0) && (greenValue != 0) && (blueValue != 0)){
		// BRANCO
		if(redValue >= 40 && greenValue >= 40 && blueValue >= 30){
			return colorWhite;
			}else{
			// VERDE
			if((redValue <= 12) && (greenValue >= 25) && (blueValue <= 15)){
				return colorGreen;
				}else{
				// VERMELHO MALDITO
				if((redValue >= 35) && (greenValue <= 15) && (blueValue <= 12)){
					return colorRed;
					}else{
					// AMARELO
					if((redValue >= 30) && (greenValue >= 15) && (blueValue <= 10)){
						return colorYellow;
						}else{
						// AZUL
						if((redValue <= 15) && (greenValue >= 30) && (blueValue >= 30)){
							return colorBlue;
							}else{
							// PRETO
							if((redValue <= 10) && (greenValue <= 10) && (blueValue <= 10)){
								return colorBlack;
							}
						}
					}
				}
			}
		}
	}
	return colorNone;
}

/*Funcao para andar x cm
** Param: distancia
*/
void anda_x_cm (float x){
	float encoder;
	int sinal;

	encoder = (x*CALIBRA_RETO);

	if (encoder >= 0){
		sinal = 1;
		} else {
		sinal = -1;
	}

	setMotorSyncEncoder(dir, esq, 0, encoder, sinal*POTENCIA);

	waitUntilMotorStop(dir);
	waitUntilMotorStop(esq);

	setMotorReversed(dir, false);
	setMotorReversed(esq, false);

}

//Estado Plaza
/*
Algorítmo:
1.Andar reto mantendo 77,5 cm* de distância entre as paredes enquanto cor (branco)
2.Quando cor for preto, usando os dados do encoder dos motores, andar por mais 30 cm (centro do círculo preto).
3.Para e levanta a cancela para depositar os bonecos.
4.Anda para trás por uma distância suficiente para sair do círculo preto e gira 180°.
5.Andar reto mantendo 77,5 cm de distância entre as paredes.
6.Ao dectetar faixas de cores mudar de estado
*comprimento do módulo: 185 cm
largura do robô: 30 cm
185-30 = 155 / 2 = 77,5
*/
void estado_plaza (){

	float sensor_esq;
	float sensor_dir;
	float diferenca;

	while (getColor(sensor_cor) != colorBlack){			//Anda para frente com uma distância de no mínimo 50cm e máximo de 100cm de distância da parede.
		if (getUSDistance(ultrassonico) >85){
			setMotorSpeed(dir, 18);
			setMotorSpeed(esq, 22);
			} else if (getUSDistance(ultrassonico) < 65) {
			setMotorSpeed(dir, 22);
			setMotorSpeed(esq, 18);
			} else {
			AndarReto (1);
		}
	}
	//Anda pra frente, abre a cancela anda para trás, fecha a cancela e gira 180°
	anda_x_cm (15);
	setMotorTarget (cancela, 120, 30);
	waitUntilMotorStop (cancela);
	anda_x_cm (-60);
	setMotorTarget (cancela, 0, 10);
	waitUntilMotorStop (cancela);
	sensor_esq = getUSDistance(S1);
	GirarRobo(180,ESQUERDA);
	sensor_dir = getUSDistance(S1);
	diferenca = (sensor_esq - sensor_dir);
	while (diferenca > 1 || diferenca < -1){
		if (diferenca > 1){
			GirarRobo(90, DIREITA);
			anda_x_cm(0.5);
			GirarRobo(90, DIREITA);
			sensor_esq = getUSDistance(S1);
			GirarRobo(180,ESQUERDA);
			sensor_dir = getUSDistance(S1);
			diferenca = (sensor_esq - sensor_dir);
			} else {
			GirarRobo(90, ESQUERDA);
			anda_x_cm(0.5);
			GirarRobo(90, ESQUERDA);
			sensor_esq = getUSDistance(S1);
			GirarRobo(180,ESQUERDA);
			sensor_dir = getUSDistance(S1);
			diferenca = (sensor_esq - sensor_dir);
		}
	}

		/*	while (getColor(sensor_cor) != colorGreen){		//Volta para a rampa, tentando manter a distância minima de 50cm e máxima de 100cm da parede
		if (getUSDistance(ultrassonico) >100){
		setMotorSpeed(dir, 18);
		setMotorSpeed(esq, 22);
		} else if (getUSDistance(ultrassonico) < 50) {
		setMotorSpeed(dir, 22);
		setMotorSpeed(esq, 18);
		} else {
		AndarReto(1);
		}
		}*/

		setMotorSpeed(dir,0);
		setMotorSpeed(esq,0);

	}


	task main{
		estado_plaza();
	}
