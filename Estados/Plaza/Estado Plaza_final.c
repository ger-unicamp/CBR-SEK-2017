#pragma config(Sensor, S1,     ultrassonico,   sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     sensor_cor,     sensorNone)
#pragma config(Motor,  motorA,          dir,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          esq,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          cancela,       tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Função que devolve a cor lida pelo sensor
TLegoColors getColor(tSensors sensor){
	bool getColor = false;
	TLegoColors color;

	while(!getColor){
		color = getColorName(sensor);
		if(color != colorNone)
			getColor = true;
		else
			getColor = false;
	}

	return color;
}

//Função que faz o robô andar uma distância desejada
void anda_x_cm (float x){ 	//O parâmetro é a distancia que deve ser percorrida
	float angulo;
	angulo = (x*20.835); //constante obtida de 360/(2*pi*r) onde r é o raio da roda
	if (angulo >= 0){		//Se distância for negativa, definimos o motor para trás
		setMotorReversed(dir, false);
		setMotorReversed(esq, false);
	} else {				//Se distância for positiva, definimos o motor para frente
		setMotorReversed(esq, true);
		setMotorReversed(dir, true);
	}
	moveMotorTarget(dir, angulo, 20);
	moveMotorTarget(esq, angulo, 20);	//Gira o motor
	waitUntilMotorStop(dir);
	waitUntilMotorStop(esq);
	setMotorReversed(dir, false);
	setMotorReversed(esq, false);	//Definimos o motor para frente (configuração inicial)
}

//Estado Plaza
/*
Algorítmo:
1.Andar reto mantendo 77,5 cm* de distância entre as paredes enquanto cor (branco)
2.Quando cor for preto, usando os dados do encoder dos motores, andar por mais 30 cm (centro do círculo preto).
3.Para e levanta a cancela para depositar os bonecos.
4.Anda para trás por uma distância suficiente para sair do círculo preto e gira 180°.
5.Andar reto mantendo 77,5 cm de distância entre as paredes.
6.Ao dectetar faixas de cores mudar de estado
*comprimento do módulo: 185 cm
largura do robô: 30 cm
185-30 = 155 / 2 = 77,5
*/
void estado_plaza (){
	while (getColor(sensor_cor) != colorBlack){			//Anda para frente com uma distância de no mínimo 50cm e máximo de 100cm de distância da parede.
		if (getUSDistance(ultrassonico) >100){
			setMotorSpeed(dir, 18);
			setMotorSpeed(esq, 22);
		} else if (getUSDistance(ultrassonico) < 50) {
			setMotorSpeed(dir, 22);
			setMotorSpeed(esq, 18);
		} else {
			setMotorSpeed(dir, 20);
			setMotorSpeed(esq, 20);
		}
	}
	//Anda 30cm, abre a cancela anda 50cm para trás, fecha a cancela e gira 180°
	anda_x_cm (30);
	setMotorTarget (cancela, 120, 10);
	waitUntilMotorStop (cancela);
	anda_x_cm (-50);
	setMotorTarget (cancela, 0, 10);
	waitUntilMotorStop (cancela);
	setMotorSpeed(dir, 50); //gira 180º faltando função !! (mero exemplo)
	setMotorSpeed(esq, -50);
	sleep (1570);
	setMotorSpeed(dir, 0);
	setMotorSpeed(esq,0);

	while (getColor(sensor_cor) != colorBlack){		//Volta para a rampa, tentando manter a distância minima de 50cm e máxima de 100cm da parede
		if (getUSDistance(ultrassonico) >100){
			setMotorSpeed(dir, 18);
			setMotorSpeed(esq, 22);
		} else if (getUSDistance(ultrassonico) < 50) {
			setMotorSpeed(dir, 22);
			setMotorSpeed(esq, 18);
		} else {
			setMotorSpeed(dir, 20);
			setMotorSpeed(esq, 20);
		}
	}
}


task main{
	estado_plaza();
}
