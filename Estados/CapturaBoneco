#pragma config(Sensor, S1,     ult,            sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     cor,            sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S3,     giro,           sensorEV3_Gyro)
#pragma config(Motor,  motorA,          dir,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          esq,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          cancela,       tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Definição de estados */
#define RETO 			1
#define INTERSECCAO		2
#define CAPTURAR		3
#define RAMPA_IDA		4
#define PLAZA			5
#define RAMPA_VOLTA		6

/* Outras definições */
#define DIST_BONECO	25 //VERIFICAR DISTANCIA QUE DEVE SER ANDANDO NO DIA DA COMPETICAO
#define DIST_ANDAR 30
#define TAM 6
#define POTENCIA 25 // 30
#define POTENCIA_GIRO 10
#define FRENTE 1
#define TRAS -1
#define ESQUERDA -1 //ESQUERDA
#define DIREITA 1 //DIREITA
#define DESLIGA 0

/*variaveis para funcao cancela*/
#define pos_abrir 140
#define vel_abrir 10
#define pos_fechar 0
#define vel_fechar 5

/*variaveis global*/
int boneco_captura = 0;
//int bonecos_total = 0;

/*andar reto
** Param: sentido
*/
void AndarReto (int sentido){
	setMotorSync(dir,esq,0,sentido*POTENCIA);
}

/*Funcao para andar x cm
** Param: distancia
*/
void GirarRobo (float x, int sentido){
float angulo;

	angulo = (x*20.835);

	if (angulo >= 0){
		setMotorReversed(dir, false);
		setMotorReversed(esq, false);
	}else {
		setMotorReversed(esq, true);
		setMotorReversed(dir, true);
	}

	//GIRAR DIREITA
	if(sentido == DIREITA){
		moveMotorTarget(dir, angulo, 20);
		moveMotorTarget(esq, angulo, -20);

		waitUntilMotorStop(dir);
		waitUntilMotorStop(esq);

		setMotorReversed(dir, false);
		setMotorReversed(esq, false);
	}else{
		moveMotorTarget(dir, angulo, -20);
		moveMotorTarget(esq, angulo, 20);

		waitUntilMotorStop(dir);
		waitUntilMotorStop(esq);

		setMotorReversed(dir, false);
		setMotorReversed(esq, false);
	}


}

/* Função para saber se existe boneco a ser recolhido ou não
** Params: nenhum
*/
bool ultrassonico(){
	int vet[11];
	int i;
	int j;
	int aux;
	int k = 10;

	//Lê 11 valores de distância em CM
	for (i=0; i<11; i++){
	        vet[i] = getUSDistance(ult);
	}

	//Bubble Sort
	for(i = 0; i < 11; i++){
		for(j = 0; j < k; j++){
			if(vet[j] > vet[j+1]){
			aux = vet[j];
			vet[j] = vet[j+1];
			vet[j+1]=aux;
			}
		}
		k--;
	}

    //Ver se o sensor achou o boneco e retorna true ou false
	if (vet[5] < DIST_BONECO){
        return true;
	}else{
	    return false;
	}
}

void funcao_cancela(int posicao, int velocidade){
	displayTextLine(4,"funcao_cancela");

	if(posicao == pos_abrir && velocidade == vel_abrir){
		displayTextLine(3,"cancela sera aberta");
		setMotorTarget (cancela,pos_abrir,vel_abrir); //Abrir cancela
		delay(3000);
	}else{
		displayTextLine(3,"cancela sera fechada");
		setMotorTarget (cancela,pos_fechar,vel_fechar); //Fechar cancela
		delay(3000);
	}

}

/*Funcao para andar x cm
** Param: distancia
*/
void anda_x_cm (float x){
float angulo;

	angulo = (x*20.835);

	if (angulo >= 0){
		setMotorReversed(dir, false);
		setMotorReversed(esq, false);
	} else {
		setMotorReversed(esq, true);
		setMotorReversed(dir, true);
	}

	moveMotorTarget(dir, angulo, 20);
	moveMotorTarget(esq, angulo, 20);

	waitUntilMotorStop(dir);
	waitUntilMotorStop(esq);

	setMotorReversed(dir, false);
	setMotorReversed(esq, false);

}

/*Funcao para pegar boneco
** Param:
*/
void pega_boneco(){
boneco_captura++;

		GirarRobo(18,DIREITA); //giro (direita) - girar 90
 		displayTextLine(3,"chamar a funcao cancela");
		funcao_cancela(pos_abrir,vel_abrir);
		displayTextLine(3,"andar x cm");
		anda_x_cm (DIST_ANDAR); //VERIFICAR A DISTANCIA NO DIA
		funcao_cancela(pos_fechar,vel_fechar);
		anda_x_cm (-DIST_ANDAR); //VERIFICAR A DISTANCIA NO DIA
		GirarRobo(18,ESQUERDA);//giro (esquerda) - girar 90

}

task main(){
	/*variaveis*/
	bool ult;
	int estado = RETO;

	displayTextLine(1,"INICIO DA TASK MAIN");

	while(true){

		ult = ultrassonico();

		if(ult == true){
			if(boneco_captura == 0){
				anda_x_cm(10); //TESTAR ESSE VALOR NA COMPETICAO
				estado = CAPTURAR;
			}
		}else{
			estado = RETO;
		}

		switch(estado){
			case 1:
				AndarReto(FRENTE);
			break;

			case 3:
				pega_boneco();
			break;

		}
	}


}
