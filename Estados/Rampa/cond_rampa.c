#pragma config(Sensor, S1,     ultraev3,       sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     color,          sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S3,     ultranxt,       sensorSONAR)
#pragma config(Motor,  motorA,          dir,           tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          esq,           tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          cancela,       tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
**
** Código principal do robô da categoria IEEE SEK 2017
** Baseado em uma máquina de estados dependente de sensores ultrassônico e de cor
** GER - Grupo de Estudos em Robótica
** 08/11/2017
**
*/

/* Definição de estados */
#define RETO 			1
#define INTERSECCAO		2
#define CAPTURAR		3
#define RAMPA		4
#define PLAZA			5
#define SEM_SAIDA		6

/* Outras definições */
#define DIST_BONECO		30
#define DIST_ANDAR 20
#define TAM 6
#define POTENCIA 20 // 30

/* Definicoes de direcoes das interseccoes */
#define DIREITA 1
#define FRENTE 2
#define ESQUERDA 3

/* Definicoes para motores */
#define TRAS -1
#define DESLIGA 0
#define POTENCIA_GIRO 10

/* Definicoes de calibracao */
#define CALIBRA_GIRO 3.25
#define CALIBRA_RETO 21.7

/*Informacoes*/
typedef struct dados{
	TLegoColors cor;
	int dir;
	/*int bonecos_total; // numero de bonecos total na pista
	int bonecos_bifurcacao; //total de bonecos presentes na bifurcacao (esquerda + direita)
	int bonecos_direita; //bonecos esquerda = bonecos_bifurcacao - bonecos_direita*/
}dados;

// Topo da pilha
int topo, interseccoes = 0;
int DIST_PISO = 0;

/*Pilha*/
typedef struct Pilha{
	int max;
	dados elems[TAM];
	//TLegoColors cor[TAM];
	//int dir[TAM];
}Pilha;

/* Variaveis globais */
int sem_saida = 0;
int estado = RETO;

/*Funcao para andar x cm
** Param: distancia
*/
void anda_x_cm (float x){
	float encoder;
	int sinal;

	encoder = (x*CALIBRA_RETO);

	if (encoder >= 0){
		sinal = 1;
		} else {
		sinal = -1;
	}

	setMotorSyncEncoder(dir, esq, 0, encoder, sinal*POTENCIA);

	waitUntilMotorStop(dir);
	waitUntilMotorStop(esq);

	setMotorReversed(dir, false);
	setMotorReversed(esq, false);

}
/* Funcao para subir rampa
** Params: nothing
*/
void rampa(){
	setMotorSync(dir,esq,0,30);
}

/*Funcao inserir
** Param: ponteiro para pilha, direcao e cor
*/
bool push (Pilha *p, TLegoColors cor, int dir){
	if(topo == p->max){ //Pilha cheia
		//displayBigTextLine(line6,"Erro: stack overflow\n");
		return false;
		}else{
		p->elems[topo].cor = cor;
		p->elems[topo++].dir = dir;
		return true;
	}
}

/*Funcao imprime
// Param: ponteiro para pilha
void imprime_pilha(Pilha p){
int i;
//displayBigTextLine(line1,"Imprimir Pilha:\n");
for(i=0;i<topo;i++){
//displayBigTextLine(line1,"cor:%d",p.elems[i].cor);
//displayBigTextLine(line2,"dir:%d",p.elems[i].dir);
}
}*/

/*Funcao andar reto
** Param: sentido
*/
void AndarReto (int sentido){
	setMotorSync(dir,esq,0,sentido*POTENCIA);
}


/*Funcao girar robo
** Param: angulo (em graus), sentido (DIREITA ou ESQUERDA)
*/
void GirarRobo (float angulo, int sentido){
	float encoder;

	encoder = (angulo*CALIBRA_GIRO);

	//GIRAR DIREITA
	if(sentido == DIREITA){
		setMotorSyncEncoder(dir,esq,-100,encoder,30);

		waitUntilMotorStop(dir);
		waitUntilMotorStop(esq);

		}else{
		if(sentido == ESQUERDA){
			setMotorSyncEncoder(dir,esq,100,encoder,30);

			waitUntilMotorStop(dir);
			waitUntilMotorStop(esq);

		}
	}
}


/* Funcao do estado captura bonecos
** Params: nothing
*/
void pega_boneco(){
	anda_x_cm (5); //teste para deixar o boneco no centro
	GirarRobo(90,ESQUERDA); //giro (direita)
	setMotorTarget (cancela, 120, 10);
	waitUntilMotorStop (cancela);
	anda_x_cm (DIST_ANDAR);
	setMotorTarget (cancela, 0, 5);
	waitUntilMotorStop (cancela);
	anda_x_cm (-DIST_ANDAR);
	GirarRobo(90,DIREITA);//giro (esquerda);
}

/* Função para Retornar a Cor lida pelo Sensor
** Params: porta conectada do sensor de cor
*/
TLegoColors getColor(tSensors sensor)
{
	//Creates variables to store the red, green, and blue values
	long int redValue;
	long int greenValue;
	long int blueValue;

	//Get the value of all three channels of the color sensor
	//and store it in the variables
	getColorRGB(sensor, redValue, greenValue, blueValue);
	// se alguma COR for detectada
	if((redValue != 0) && (greenValue != 0) && (blueValue != 0)){
		// BRANCO
		if(redValue >= 40 && greenValue >= 40 && blueValue >= 30){
			return colorWhite;
			}else{
			// VERDE
			if((redValue <= 12) && (greenValue >= 25) && (blueValue <= 15)){
				return colorGreen;
				}else{
				// VERMELHO MALDITO
				if((redValue >= 35) && (greenValue <= 15) && (blueValue <= 12)){
					return colorRed;
					}else{
					// AMARELO
					if((redValue >= 30) && (greenValue >= 15) && (blueValue <= 10)){
						return colorYellow;
						}else{
						// AZUL
						if((redValue <= 15) && (greenValue >= 30) && (blueValue >= 30)){
							return colorBlue;
							}else{
							// PRETO
							if((redValue <= 10) && (greenValue <= 10) && (blueValue <= 10)){
								return colorBlack;
							}
						}
					}
				}
			}
		}
	}
	return colorNone;
}

bool ultrassonico(tSensors sensor){
	int vet[11];
	int i;
	int j;
	int aux;
	int k = 10;
	if(sensor == ultraev3){
		//Lê 11 valores de distância em CM
		for (i=0; i<11; i++){
			vet[i] = getUSDistance(sensor);
		}

		//Bubble Sort
		for(i = 0; i < 11; i++){
			for(j = 0; j < k; j++){
				if(vet[j] > vet[j+1]){
					aux = vet[j];
					vet[j] = vet[j+1];
					vet[j+1]=aux;
				}
			}
			k--;
		}

		//Ver se o sensor achou o boneco e retorna true ou false
		if (vet[5] < DIST_BONECO){
			return true;
			}else{
			return false;
		}
	}
	else{
		if(sensor == ultranxt){
			for (i=0; i<11; i++){
				vet[i] = SensorValue[S3];
			}
			//Bubble Sort
			for(i = 0; i < 11; i++){
				for(j = 0; j < k; j++){
					if(vet[j] > vet[j+1]){
						aux = vet[j];
						vet[j] = vet[j+1];
						vet[j+1]=aux;
					}
				}
				k--;
			}
			if(vet[5] > DIST_PISO){
				return true;
			}
			else
				return false;
		}
	}
	return false;
}

/*Funcao para verificar se cor esta na pilha
** Param: ponteiro para pilha, cor
*/
bool checa_cor(Pilha p, TLegoColors cor){
	int i;
	for(i=0;i<TAM;i++){
		if(p.elems[i].cor == cor){
			//displayBigTextLine(line1,"ndeu certo");
			return true;
		}
	}
	return false;
}

/*Funcao para verificar se dir esta na pilha
** Param: ponteiro para pilha, direcao, cor

bool checa_dir(Pilha p, int dir, TLegoColors cor){
int i;
for(i=0;i<TAM;i++){
if(p.elems[i].dir == dir){
if(p.elems[i].cor == cor){
return true;
}else{
return false;
}
}
}
return false;
}*/

/*Funcao troca sentido
** Param: ponteiro para pilha
*/
void troca(Pilha *p){
int i;

	for(i=0;i<p->topo;i++){
		if(p->elems[i].dir == FRENTE){
			p->elems[i].dir = TRAS;
		}else if(p->elems[i].dir == ESQUERDA){
			p->elems[i].dir = DIREITA;
		}else if(p->elems[i].dir == DIREITA){
			p->elems[i].dir = ESQUERDA;
		}
	}
}

/*
** Funcao para mudar direcao da cor na pilha
*/
bool increment_dir(Pilha *p, TLegoColors cor){
	int i;
	for(i=0;i<TAM;i++){
		if(cor == p->elems[i].cor){
			p->elems[i].dir++;
			return true;
		}
	}
	return false;
}


/*Funcao para o estado interseccao
** Param: ponteiro para pilha, cor
*/
void interseccao(Pilha &p, TLegoColors cor){

	int i;
	int direcao;
	if(!checa_cor(p,cor)){ //se cor for diferente de branco e nao estiver na pilha...
		push(p,cor,DIREITA);
		playSound(soundLowBuzzShort);
		//	setLEDColor(ledGreenFlash);
		//displayBigTextLine(line2,"PUSH NA PILHA");
		GirarRobo(90, DIREITA);
		anda_x_cm(25);
		interseccoes++;
		}else{
		if(sem_saida == 1){
			setLEDColor(ledRedPulse);
			playSound(soundFastUpwardTones);
			GirarRobo(90,DIREITA);
			anda_x_cm(25);
			increment_dir(p, cor);
			sem_saida = 0;
			}else{
			for(i=0;i<TAM;i++){
				if(cor == p.elems[i].cor){
					//displayBigTextLine(line4,"temos cor");
					direcao = p.elems[i].dir;
					interseccoes++;
					if(direcao == DIREITA)
					{
						GirarRobo(90, DIREITA);
					}
					else{
						if(direcao == ESQUERDA)
						{
							GirarRobo(90, ESQUERDA);
						}
					}
					setLEDColor(ledOrangeFlash);
					anda_x_cm(30);

				}
			}
		}
		estado = RETO;
	}
}

//Estado Plaza
/*
Algorítmo:
1.Andar reto mantendo 77,5 cm* de distância entre as paredes enquanto cor (branco)
2.Quando cor for preto, usando os dados do encoder dos motores, andar por mais 30 cm (centro do círculo preto).
3.Para e levanta a cancela para depositar os bonecos.
4.Anda para trás por uma distância suficiente para sair do círculo preto e gira 180°.
5.Andar reto mantendo 77,5 cm de distância entre as paredes.
6.Ao dectetar faixas de cores mudar de estado
*comprimento do módulo: 185 cm
largura do robô: 30 cm
185-30 = 155 / 2 = 77,5
*/
void estado_plaza(){

	float sensor_esq;
	float sensor_dir;
	float diferenca;

	while (getColor(color) != colorBlack){			//Anda para frente com uma distância de no mínimo 50cm e máximo de 100cm de distância da parede.
		if (getUSDistance(ultraev3) >85){
			setMotorSpeed(dir, 18);
			setMotorSpeed(esq, 22);
			} else if (getUSDistance(ultraev3) < 65) {
			setMotorSpeed(dir, 22);
			setMotorSpeed(esq, 18);
			} else {
			AndarReto (1);
		}
	}
	//Anda pra frente, abre a cancela anda para trás, fecha a cancela e gira 180°
	anda_x_cm (15);
	setMotorTarget (cancela, 120, 30);
	waitUntilMotorStop (cancela);
	anda_x_cm (-60);
	setMotorTarget (cancela, 0, 10);
	waitUntilMotorStop (cancela);
	sensor_esq = getUSDistance(S1);
	GirarRobo(180,ESQUERDA);
	sensor_dir = getUSDistance(S1);
	diferenca = (sensor_esq - sensor_dir);
	while (diferenca > 1 || diferenca < -1){
		if (diferenca > 1){
			GirarRobo(90, DIREITA);
			anda_x_cm(0.5);
			GirarRobo(90, DIREITA);
			sensor_esq = getUSDistance(S1);
			GirarRobo(180,ESQUERDA);
			sensor_dir = getUSDistance(S1);
			diferenca = (sensor_esq - sensor_dir);
			} else {
			GirarRobo(90, ESQUERDA);
			anda_x_cm(0.5);
			GirarRobo(90, ESQUERDA);
			sensor_esq = getUSDistance(S1);
			GirarRobo(180,ESQUERDA);
			sensor_dir = getUSDistance(S1);
			diferenca = (sensor_esq - sensor_dir);
		}
	}

	/*	while (getColor(sensor_cor) != colorGreen){		//Volta para a rampa, tentando manter a distância minima de 50cm e máxima de 100cm da parede
	if (getUSDistance(ultrassonico) >100){
	setMotorSpeed(dir, 18);
	setMotorSpeed(esq, 22);
	} else if (getUSDistance(ultrassonico) < 50) {
	setMotorSpeed(dir, 22);
	setMotorSpeed(esq, 18);
	} else {
	AndarReto(1);
	}
	}*/

	setMotorSpeed(dir,0);
	setMotorSpeed(esq,0);

}

/* Funcao para o estado sem saida
** Param:
*/
void semSaida(){
	playSound(soundLowBuzz);
	GirarRobo(180, ESQUERDA);
	sem_saida = 1;
	anda_x_cm(30);
	estado = RETO;
}

task main(){
	playSound(soundException);

	Pilha p;
	int i, aux;
	bool ultev3, ultnxt, plaza = false;
	TLegoColors cor, cor_aux;

	/* inicialização necessárias */
	p.max = TAM;
	topo = 0;
	for(i=0;i<TAM;i++){
		p.elems[i].cor = colorBrown; /*testar inicialziar*/
		p.elems[i].dir = 0;
	}
	for(i=0; i < 10; i++){
		aux = SensorValue[S3];
		if(aux > DIST_PISO)
			DIST_PISO = aux;
	}

	while(true){

		cor = getColor(S2);

		if(cor != colorNone){
			if(cor == colorBlack){
				AndarReto(DESLIGA);
				delay(1000);
				cor = getColor(S2);

				if(cor == colorBlack){
					AndarReto(TRAS);
					delay(1000);
					AndarReto(DESLIGA);
					estado = SEM_SAIDA;
					playSoundFile("Dog whine");
				}
			}
			else{
				ultnxt = ultrassonico(ultranxt);
				if(!ultnxt){
					if(cor == colorYellow || cor == colorGreen || cor == colorRed){
						anda_x_cm(3);
						AndarReto(DESLIGA);
						delay(500);
						cor_aux = getColor(S2);
						if(interseccoes == 4){
							estado = RAMPA;
						}
						else{
							if(cor_aux == cor){
								//displayText(line1,"estado interseccao")
								estado = INTERSECCAO;

							}
						}
					}
					else{
						if(cor == colorWhite){
							if(plaza == false){
								estado = RETO;
								ultev3 = ultrassonico(ultraev3);
								if(ultev3){
									estado = CAPTURAR;
								}
							}
							else{
								estado = PLAZA;
							}
						}
					}
				}
				else{
					while(ultrassonico(ultranxt)){
						AndarReto(DESLIGA);
						AndarReto(TRAS);
						delay(500);
						GirarRobo(10, ESQUERDA);
						GirarRobo(6, DIREITA);
						delay(1000);
					}
				}
			}
		}
		switch(estado){
		case INTERSECCAO:
			interseccao(p,cor);
			break;
		case RETO:
			AndarReto(1);
			break;
		case SEM_SAIDA:
			semSaida();
			break;
		case CAPTURAR:
			pega_boneco();
			break;
		case RAMPA:
			rampa();
			plaza = !plaza;
			break;
		case PLAZA:
			interseccoes = 0;
			estado_plaza();
			plaza = false;
			break;
		}
	}

}
