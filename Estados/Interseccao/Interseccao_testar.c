#pragma config(Sensor, S1,     ult,            sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     color,          sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S3,     gyro,           sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Motor,  motorA,          dir,           tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          esq,           tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          cancela,       tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
**
** Código principal do robô da categoria IEEE SEK 2017
** Baseado em uma máquina de estados dependente de sensores ultrassônico e de cor
** GER - Grupo de Estudos em Robótica
** 01/11/2017
**
*/

/* Definição de estados */
#define RETO 			1
#define INTERSECCAO		2
#define CAPTURAR		3
#define RAMPA_IDA		4
#define PLAZA			5
#define RAMPA_VOLTA		6
#define SEM_SAIDA		7

/* Outras definições */
#define DIST_BONECO		25
#define DIST_ANDAR 30
#define TAM 6
#define POTENCIA 20 // 30

/* Definicoes de direcoes das interseccoes */
#define DIREITA 1
#define FRENTE 2
#define ESQUERDA 3

/* Definicoes para motores */
#define TRAS -1
#define ANTIHORARIO -1 //ESQUERDA
#define HORARIO 1 //DIREITA
#define DESLIGA 0
#define POTENCIA_GIRO 10

/*Informacoes*/
typedef struct dados{
	TLegoColors cor;
	int dir;
	int bonecos_total; // numero de bonecos total na pista
	int bonecos_bifurcacao; //total de bonecos presentes na bifurcacao (esquerda + direita)
	int bonecos_direita; //bonecos esquerda = bonecos_bifurcacao - bonecos_direita
}dados;

// Topo da pilha
int topo;

/*Pilha*/
typedef struct Pilha{
	int max;
	dados elems[TAM];
	//TLegoColors cor[TAM];
	//int dir[TAM];
}Pilha;

/* Variaveis globais */
int sem_saida = 0;
int estado = RETO;

/*Funcao para andar x cm
** Param: distancia
*/
void anda_x_cm (float x){
	float angulo;

	angulo = (x*20.835);

	if (angulo >= 0){
		setMotorReversed(dir, false);
		setMotorReversed(esq, false);
		} else {
		setMotorReversed(esq, true);
		setMotorReversed(dir, true);
	}

	moveMotorTarget(dir, angulo, 20);
	moveMotorTarget(esq, angulo, 20);

	waitUntilMotorStop(dir);
	waitUntilMotorStop(esq);

	setMotorReversed(dir, false);
	setMotorReversed(esq, false);

}

/*Funcao inserir
** Param: ponteiro para pilha, direcao e cor
*/
bool push (Pilha *p, TLegoColors cor, int dir){
	if(topo == p->max){ //Pilha cheia
		//displayBigTextLine(line6,"Erro: stack overflow\n");
		return false;
		}else{
		p->elems[topo].cor = cor;
		p->elems[topo++].dir = dir;
		return true;
	}
}

/*Funcao imprime
// Param: ponteiro para pilha
void imprime_pilha(Pilha p){
	int i;
	//displayBigTextLine(line1,"Imprimir Pilha:\n");
	for(i=0;i<topo;i++){
		//displayBigTextLine(line1,"cor:%d",p.elems[i].cor);
		//displayBigTextLine(line2,"dir:%d",p.elems[i].dir);
	}
}*/

/*Funcao andar reto
** Param: sentido
*/
void AndarReto (int sentido){
	setMotorSync(dir,esq,0,sentido*POTENCIA);
}

/*Funcao girar robo
** Param: angulo, sentido
*/

/*Funcao para andar x cm
** Param: distancia
*/
void GirarRobo (float x, int sentido){
	float angulo;

	angulo = (x*20.835);

	if (angulo >= 0){
		setMotorReversed(dir, false);
		setMotorReversed(esq, false);
		}else {
		setMotorReversed(esq, true);
		setMotorReversed(dir, true);
	}

	//GIRAR DIREITA
	if(sentido == DIREITA){
		moveMotorTarget(dir, angulo, -20);
		moveMotorTarget(esq, angulo, 20);

		waitUntilMotorStop(dir);
		waitUntilMotorStop(esq);

		setMotorReversed(dir, false);
		setMotorReversed(esq, false);
		}else{
		if(sentido == ESQUERDA){
			moveMotorTarget(dir, angulo, 20);
			moveMotorTarget(esq, angulo, -20);

			waitUntilMotorStop(dir);
			waitUntilMotorStop(esq);

			setMotorReversed(dir, false);
			setMotorReversed(esq, false);
			}else{
			AndarReto(1);
			delay(2000);
		}
	}


}

/* Função para Retornar a Cor lida pelo Sensor
** Params: porta conectada do sensor de cor
*/
TLegoColors getColor(tSensors sensor)
{
	//Creates variables to store the red, green, and blue values
	long int redValue;
	long int greenValue;
	long int blueValue;

	//Get the value of all three channels of the color sensor
	//and store it in the variables
	getColorRGB(sensor, redValue, greenValue, blueValue);
	// se alguma COR for detectada
	if((redValue != 0) && (greenValue != 0) && (blueValue != 0)){
		// BRANCO
		if(redValue >= 40 && greenValue >= 40 && blueValue >= 30){
			return colorWhite;
			}else{
			// VERDE
			if((redValue <= 12) && (greenValue >= 25) && (blueValue <= 15)){
				return colorGreen;
				}else{
				// VERMELHO MALDITO
				if((redValue >= 35) && (greenValue <= 15) && (blueValue <= 12)){
					return colorRed;
					}else{
					// AMARELO
					if((redValue >= 30) && (greenValue >= 15) && (blueValue <= 10)){
						return colorYellow;
						}else{
						// AZUL
						if((redValue <= 15) && (greenValue >= 30) && (blueValue >= 30)){
							return colorBlue;
							}else{
							// PRETO
							if((redValue <= 10) && (greenValue <= 10) && (blueValue <= 10)){
								return colorBlack;
							}
						}
					}
				}
			}
		}
	}
	return colorNone;
}


bool ultrassonico(){
	int vet[11];
	int i;
	int j;
	int aux;
	int k = 10;

	//Lê 11 valores de distância em CM
	for (i=0; i<11; i++){
		vet[i] = getUSDistance(ult);
	}

	//Bubble Sort
	for(i = 0; i < 11; i++){
		for(j = 0; j < k; j++){
			if(vet[j] > vet[j+1]){
				aux = vet[j];
				vet[j] = vet[j+1];
				vet[j+1]=aux;
			}
		}
		k--;
	}

	//Ver se o sensor achou o boneco e retorna true ou false
	if (vet[5] < DIST_BONECO){
		return true;
		}else{
		return false;
	}
}

/*Funcao para verificar se cor esta na pilha
** Param: ponteiro para pilha, cor
*/
bool checa_cor(Pilha p, TLegoColors cor){
	int i;
	for(i=0;i<TAM;i++){
		if(p.elems[i].cor == cor){
			//displayBigTextLine(line1,"ndeu certo");
			return true;
		}
	}
	return false;
}

/*Funcao para verificar se dir esta na pilha
** Param: ponteiro para pilha, direcao, cor

bool checa_dir(Pilha p, int dir, TLegoColors cor){
	int i;
	for(i=0;i<TAM;i++){
		if(p.elems[i].dir == dir){
			if(p.elems[i].cor == cor){
				return true;
				}else{
				return false;
			}
		}
	}
	return false;
}*/

/*Funcao para o estado interseccao
** Param: ponteiro para pilha, cor
*/
void interseccao(Pilha &p, TLegoColors cor){

	int i;

	if(!checa_cor(p,cor)){ //se cor for diferente de branco e nao estiver na pilha...
		push(&p,cor,DIREITA);
		playSound(soundLowBuzzShort);
		//	setLEDColor(ledGreenFlash);
		//displayBigTextLine(line2,"PUSH NA PILHA");
		GirarRobo(18, DIREITA);
		anda_x_cm(25);
		}else{
		if(sem_saida == 1){
			setLEDColor(ledRedPulse);
			playSound(soundFastUpwardTones);
			GirarRobo(18,DIREITA);
			anda_x_cm(15);
			p.elems[topo].dir++;
			sem_saida = 0;
			}else{
			for(i=0;i<TAM;i++){
				if(cor == p.elems[i].cor){
					//displayBigTextLine(line4,"temos cor");
					setLEDColor(ledOrangeFlash);
					GirarRobo(18,p.elems[i].dir);
					AndarReto(1);
					delay(3000);

				}
			}
		}
		estado = RETO;
	}
}

/* Funcao para o estado sem saida
** Param:
*/
void semSaida(){
	playSound(soundLowBuzz);
	GirarRobo(36, HORARIO);
	sem_saida = 1;
	estado = RETO;
}

task main(){
	playSound(soundException);

	Pilha p;
	int i;
	bool ult;
	TLegoColors cor;

	/* inicialização necessárias */
	p.max = TAM;
	topo = 0;
	for(i=0;i<TAM;i++){
		p.elems[i].cor = colorBrown; /*testar inicialziar*/
		p.elems[i].dir = 0;
	}

	while(true){
		ult = ultrassonico();
		cor = getColor(S2);

		if(cor != colorNone){
			if(cor == colorBlack){
				anda_x_cm (5); // tentar tirando isso
				cor = getColor(S2);
				if(cor == colorBlack){
					AndarReto(DESLIGA);
					delay(1000);
					estado = SEM_SAIDA;
					playSound(soundUpwardTones);
				}
			}
			else{
				if(cor == colorYellow || cor == colorGreen || cor == colorRed){
					anda_x_cm (20);
					AndarReto(DESLIGA);
					delay(1000);
					cor = getColor(S2);
					if(cor == colorYellow || cor == colorGreen || cor == colorRed){
						//displayText(line1,"estado interseccao");
						estado = INTERSECCAO;
					}
					}else{
					if(cor == colorWhite){
						estado = RETO;
					}
				}

				switch(estado){
				case INTERSECCAO:
					interseccao(p,cor);
					break;
				case RETO:
					AndarReto(1);
					break;
				case SEM_SAIDA:
					semSaida();
					break;
				}
			}
		}
	}
}
