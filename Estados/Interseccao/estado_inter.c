#pragma config(Sensor, S1,     ult,            sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     color,          sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S3,     gyro,           sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Motor,  motorA,          dir,           tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          esq,           tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          cancela,       tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
**
** Código principal do robô da categoria IEEE SEK 2017
** Baseado em uma máquina de estados dependente de sensores ultrassônico e de cor
** GER - Grupo de Estudos em Robótica
** 01/11/2017
**
*/

/* Definição de estados */
#define RETO 			1
#define INTERSECCAO		2
#define CAPTURAR		3
#define RAMPA_IDA		4
#define PLAZA			5
#define RAMPA_VOLTA		6
#define SEM_SAIDA		7

/* Outras definições */
#define DIST_BONECO		25
#define DIST_ANDAR 30
#define TAM 6
#define POTENCIA 20 // 30

/* Definicoes de direcoes das interseccoes */
#define DIREITA 1
#define FRENTE 2
#define ESQUERDA 3

/* Definicoes para motores */
#define TRAS -1
#define ANTIHORARIO -1 //ESQUERDA
#define HORARIO 1 //DIREITA
#define DESLIGA 0
#define POTENCIA_GIRO 10

/*Informacoes*/
typedef struct dados{
	TLegoColors cor;
	int dir;
	int bonecos_total; // numero de bonecos total na pista
	int bonecos_bifurcacao; //total de bonecos presentes na bifurcacao (esquerda + direita)
	int bonecos_direita; //bonecos esquerda = bonecos_bifurcacao - bonecos_direita
}dados;

// Topo da pilha
int topo;

/*Pilha*/
typedef struct Pilha{
	int max;
	dados elems[TAM];
	//TLegoColors cor[TAM];
	//int dir[TAM];
}Pilha;

/* Variaveis globais */
int sem_saida = 0;
int estado = RETO;

/*Funcao para andar x cm
** Param: distancia
*/
void anda_x_cm (float x){
	float angulo;

	angulo = (x*20.835);

	if (angulo >= 0){
		setMotorReversed(dir, false);
		setMotorReversed(esq, false);
		} else {
		setMotorReversed(esq, true);
		setMotorReversed(dir, true);
	}

	moveMotorTarget(dir, angulo, 20);
	moveMotorTarget(esq, angulo, 20);

	waitUntilMotorStop(dir);
	waitUntilMotorStop(esq);

	setMotorReversed(dir, false);
	setMotorReversed(esq, false);

}

/*Funcao inserir
** Param: ponteiro para pilha, direcao e cor
*/
bool push (Pilha *p, TLegoColors cor, int dir){
	if(topo == p->max){ //Pilha cheia
		//displayBigTextLine(line6,"Erro: stack overflow\n");
		return false;
		}else{
		p->elems[topo].cor = cor;
		p->elems[topo++].dir = dir;
		return true;
	}
}

//Funcao imprime
// Param: ponteiro para pilha
void imprime_pilha(Pilha p){
	int i;
	//displayBigTextLine(line1,"Imprimir Pilha:\n");
	for(i=0;i<topo;i++){
		//displayBigTextLine(line1,"cor:%d",p.elems[i].cor);
		//displayBigTextLine(line2,"dir:%d",p.elems[i].dir);
	}
}

/*Funcao andar reto
** Param: sentido
*/
void AndarReto (int sentido){
	setMotorSync(dir,esq,0,sentido*POTENCIA);
}

/*Funcao girar robo
** Param: angulo, sentido
*/

/*Funcao para andar x cm
** Param: distancia
*/
void GirarRobo (float x, int sentido){
	float angulo;

	angulo = (x*20.835);

	if (angulo >= 0){
		setMotorReversed(dir, false);
		setMotorReversed(esq, false);
		}else {
		setMotorReversed(esq, true);
		setMotorReversed(dir, true);
	}

	//GIRAR DIREITA
	if(sentido == DIREITA){
		moveMotorTarget(dir, angulo, -20);
		moveMotorTarget(esq, angulo, 20);

		waitUntilMotorStop(dir);
		waitUntilMotorStop(esq);

		setMotorReversed(dir, false);
		setMotorReversed(esq, false);
		}else{
		if(sentido == ESQUERDA){
			moveMotorTarget(dir, angulo, 20);
			moveMotorTarget(esq, angulo, -20);

			waitUntilMotorStop(dir);
			waitUntilMotorStop(esq);

			setMotorReversed(dir, false);
			setMotorReversed(esq, false);
		}else{
			AndarReto(1);
			delay(2000);
		}
	}


}

/* Função para Retornar a Cor lida pelo Sensor
** Params: porta conectada do sensor de cor
*/
TLegoColors getColor(tSensors sensor){
	bool getColor = false;
	TLegoColors color;

	while(!getColor){
		color = getColorName(sensor);
		if(color != colorNone)
			getColor = true;
		else
			getColor = false;
	}

	return color;
}

bool ultrassonico(){
	int vet[11];
	int i;
	int j;
	int aux;
	int k = 10;

	//Lê 11 valores de distância em CM
	for (i=0; i<11; i++){
		vet[i] = getUSDistance(ult);
	}

	//Bubble Sort
	for(i = 0; i < 11; i++){
		for(j = 0; j < k; j++){
			if(vet[j] > vet[j+1]){
				aux = vet[j];
				vet[j] = vet[j+1];
				vet[j+1]=aux;
			}
		}
		k--;
	}

	//Ver se o sensor achou o boneco e retorna true ou false
	if (vet[5] < DIST_BONECO){
		return true;
		}else{
		return false;
	}
}

/*Funcao para verificar se cor esta na pilha
** Param: ponteiro para pilha, cor
*/
bool checa_cor(Pilha p, TLegoColors cor){
	int i;
	for(i=0;i<TAM;i++){
		if(p.elems[i].cor == cor){
			//displayBigTextLine(line1,"ndeu certo");
			return true;
		}
	}
	return false;
}

/*Funcao para verificar se dir esta na pilha
** Param: ponteiro para pilha, direcao, cor
*/
bool checa_dir(Pilha p, int dir, TLegoColors cor){
	int i;
	for(i=0;i<TAM;i++){
		if(p.elems[i].dir == dir){
			if(p.elems[i].cor == cor){
				//displayBigTextLine(line1,"ndeu certo"); //Cor e direcao salvo
				return true;
				}else{
				return false;
			}
		}
	}
	return false;
}

/*Funcao para o estado interseccao
** Param: ponteiro para pilha, cor
*/
void interseccao(Pilha p, TLegoColors cor){

	int i;

	if(!checa_cor(p,cor)){ //se cor for diferente de branco e nao estiver na pilha...
		push(&p,cor,DIREITA);
		playSound(soundLowBuzzShort);
		//	setLEDColor(ledGreenFlash);
		//displayBigTextLine(line2,"PUSH NA PILHA");
		GirarRobo(18, DIREITA);
		anda_x_cm(25);
		}else{
		if(sem_saida == 1){
			setLEDColor(ledRedPulse);
			playSound(soundFastUpwardTones);
			p.elems[topo].dir++;
			sem_saida = 0;
			}else{
			for(i=0;i<TAM;i++){
				if(cor == p.elems[i].cor){
					//displayBigTextLine(line4,"temos cor");
					setLEDColor(ledOrangeFlash);
					GirarRobo(18,p.elems[i].dir);
					AndarReto(1);
					delay(3000);

				}
			}
		}
		estado = RETO;
	}

	/*
	if(!checa_cor(p,cor)){
	push(p,cor,DIREITA);
	for(i=0;i<TAM;i++){
	if(cor == p.elems[i].cor){
	displayBigTextLine(line4,"temos cor");
	setLEDColor(ledRedFlash);
	GirarRobo(18,p.elems[i].dir);
	anda_x_cm(30);
	estado = RETO;
	}else{
	if()
	}*/
}

/* Funcao para o estado sem saida
** Param:
*/
void semSaida(){
	//displayBigTextLine(line1,"RUA SEM SAIDA");
	playSound(soundLowBuzz);
	GirarRobo(36, HORARIO);
	sem_saida = 1;
	estado = RETO;
}

task main(){

	//displayText(line1,"task main -- 1");

	playSound(soundException);

	Pilha p;
	int i;
	bool ult;
	TLegoColors cor;


	/* inicialização necessárias */
	p.max = TAM;
	topo = 0;
	for(i=0;i<TAM;i++){
		p.elems[i].cor = colorBrown; /*testar inicialziar*/
		p.elems[i].dir = 0;
	}

	while(true){
		ult = ultrassonico();
		cor = getColor(S2);

		if(cor == colorBlack){
				anda_x_cm (5);
				cor = getColor(S2);
				if(cor == colorBlack){
					AndarReto(DESLIGA);
					delay(1000);
					estado = SEM_SAIDA;
				}
				playSound(soundUpwardTones);
			}else{
			if(cor == colorBlue || cor == colorGreen || cor == colorRed){
				anda_x_cm (15);
				AndarReto(DESLIGA);
				delay(1000);
				cor = getColor(S2);
				if(cor == colorBlue || cor == colorGreen){
					//displayText(line1,"estado interseccao");
					estado = INTERSECCAO;
				}
				}else{
				if(cor == colorWhite){
					estado = RETO;
				}/*else{
					AndarReto(DESLIGA);
					delay(10000);
				}*/
			}
		}

		switch(estado){
		case INTERSECCAO:
			interseccao(p,cor);
			//imprime_pilha(p);
			break;
		case RETO:
			AndarReto(1);
			break;
		case SEM_SAIDA:
			semSaida();
			break;
		}

	}
}
