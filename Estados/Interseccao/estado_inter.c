#pragma config(Sensor, S1,     ult,            sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     cor,            sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S3,     gyro,           sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Motor,  motorA,          dir,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          esq,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          cancela,       tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
**
** Código principal do robô da categoria IEEE SEK 2017
** Baseado em uma máquina de estados dependente de sensores ultrassônico e de cor
** GER - Grupo de Estudos em Robótica
** 01/11/2017
**
*/

/* Definição de estados */
#define RETO 			1
#define INTERSECCAO		2
#define CAPTURAR		3
#define RAMPA_IDA		4
#define PLAZA			5
#define RAMPA_VOLTA		6
#define SEM_SAIDA		7

/* Outras definições */
#define DIST_BONECO		25
#define DIST_ANDAR 30
#define TAM 6
#define POTENCIA 20 // 30

/* Definicoes de direcoes das interseccoes */
#define DIREITA 1
#define FRENTE 2
#define ESQUERDA 3

/* Definicoes para motores */
#define TRAS -1
#define ANTIHORARIO -1 //ESQUERDA
#define HORARIO 1 //DIREITA
#define DESLIGA 0
#define POTENCIA_GIRO 10

/*Informacoes*/
typedef struct dados{
	TLegoColors cor;
	int dir;
	int bonecos_total; // numero de bonecos total na pista
	int bonecos_bifurcacao; //total de bonecos presentes na bifurcacao (esquerda + direita)
	int bonecos_direita; //bonecos esquerda = bonecos_bifurcacao - bonecos_direita
}dados;

/*Pilha*/
typedef struct Pilha{
	int max;
	int topo;
	dados elems[TAM];
}Pilha;

/* Variaveis globais */
int sem_saida = 0;
int estado = RETO;

/*Funcao para andar x cm
** Param: distancia
*/
void anda_x_cm (float x){
	float angulo;

	angulo = (x*20.835);

	if (angulo >= 0){
		setMotorReversed(dir, false);
		setMotorReversed(esq, false);
		} else {
		setMotorReversed(esq, true);
		setMotorReversed(dir, true);
	}

	moveMotorTarget(dir, angulo, 20);
	moveMotorTarget(esq, angulo, 20);

	waitUntilMotorStop(dir);
	waitUntilMotorStop(esq);

	setMotorReversed(dir, false);
	setMotorReversed(esq, false);

}

/*Funcao inserir
** Param: ponteiro para pilha, direcao e cor
*/
bool push (Pilha p, TLegoColors cor, int dir){
	if(p.topo == p.max){ //Pilha cheia
		displayBigTextLine(line6,"Erro: stack overflow\n");
		return false;
		}else{
		p.elems[p.topo].cor = cor;
		p.elems[p.topo++].dir = dir;
		return true;
	}
}

//Funcao imprime
// Param: ponteiro para pilha
void imprime_pilha(Pilha p){
	int i;
	displayBigTextLine(line1,"Imprimir Pilha:\n");
	for(i=0;i<p.topo;i++){
		displayBigTextLine(line1,"cor:%d",p.elems[i].cor);
		displayBigTextLine(line2,"dir:%d",p.elems[i].dir);
	}
}

/*Funcao andar reto
** Param: sentido
*/
void AndarReto (int sentido){
	setMotorSync(dir,esq,0,sentido*POTENCIA);
}

/*Funcao girar robo
** Param: angulo, sentido
*/
void GirarRobo(int degree, int sentido){
	//Direita Angulo Negativo - angulo diminou se for para direita
	//Esquerda Angulo Positivo = angulo aumenta se for para esquerda

	//SET GIRO
	AndarReto(DESLIGA);

	//Verificar Angulo
	if(degree == 90){
		degree = degree - 5;
		}else if(degree == 180){
		displayTextLine(1,"ANGULO 180");
		degree = degree - 10;
	}

	if(degree == 0 && sentido == FRENTE){
		AndarReto(1);
	}

	resetGyro(S3);
	delay(1500);

	repeatUntil(abs(getGyroDegrees(S3)) > degree){
		if(sentido == HORARIO){ //Gira para direita
			displayTextLine(3,"girando sentido horario");
			setMotorSpeed(esq, FRENTE*POTENCIA_GIRO);
			setMotorSpeed(dir, TRAS*POTENCIA_GIRO);
			//delay(2000);
			}else{
			displayTextLine(3,"girando sentido antihorario");
			setMotorSpeed(esq, TRAS*POTENCIA_GIRO);
			setMotorSpeed(dir, FRENTE*POTENCIA_GIRO);
			//delay(2000);
		}
	}

	//Stop the motors at the end of the turn

	resetGyro(S3);
	delay(1000);
	AndarReto(DESLIGA);

}

/* Função para Retornar a Cor lida pelo Sensor
** Params: porta conectada do sensor de cor
*/
TLegoColors getColor(tSensors sensor){
	bool getColor = false;
	TLegoColors color;

	while(!getColor){
		color = getColorName(sensor);
		if(color != colorNone)
			getColor = true;
		else
			getColor = false;
	}

	return color;
}

bool ultrassonico(){
	int vet[11];
	int i;
	int j;
	int aux;
	int k = 10;

	//Lê 11 valores de distância em CM
	for (i=0; i<11; i++){
		vet[i] = getUSDistance(ult);
	}

	//Bubble Sort
	for(i = 0; i < 11; i++){
		for(j = 0; j < k; j++){
			if(vet[j] > vet[j+1]){
				aux = vet[j];
				vet[j] = vet[j+1];
				vet[j+1]=aux;
			}
		}
		k--;
	}

	//Ver se o sensor achou o boneco e retorna true ou false
	if (vet[5] < DIST_BONECO){
		return true;
		}else{
		return false;
	}
}

/*Funcao para verificar se cor esta na pilha
** Param: ponteiro para pilha, cor
*/
bool checa_cor(Pilha p, TLegoColors cor){
	int i;
	for(i=0;i<TAM;i++){
		if(p.elems[i].cor == cor){
			displayBigTextLine(line1,"ndeu certo");
			return true;
		}
	}
	return false;
}

/*Funcao para verificar se dir esta na pilha
** Param: ponteiro para pilha, direcao, cor
*/
bool checa_dir(Pilha p, int dir, TLegoColors cor){
	int i;
	for(i=0;i<TAM;i++){
		if(p.elems[i].dir == dir){
			if(p.elems[i].cor == cor){
				displayBigTextLine(line1,"ndeu certo"); //Cor e direcao salvo
				return true;
				}else{
				return false;
			}
		}
	}
	return false;
}

/*Funcao para o estado interseccao
** Param: ponteiro para pilha, cor
*/
void interseccao(Pilha p, TLegoColors cor){
	int i;

	if(!checa_cor(p,cor)){ //se cor for diferente de branco e nao estiver na pilha...
		push(p,cor,DIREITA);
		}else{
		if(sem_saida == 1){
			p.elems[p.topo].dir++;
			sem_saida = 0;
			}else{
			for(i=0;i<TAM;i++){
				if(cor == p.elems[i].cor){
					GirarRobo(90,p.elems[i].dir);
					AndarReto(1);
					delay(1000);
					estado = RETO;
				}
			}
		}
	}
}

/* Funcao para o estado sem saida
** Param:
*/
void semSaida(){
	GirarRobo(180, HORARIO);
	sem_saida = 1;
	estado = RETO;
}

task main(){

	displayText(line1,"task main -- 1");

	Pilha p;
	int i;
	bool ult;
	TLegoColors cor;


	/* inicialização necessárias */
	p.max = TAM;
	p.topo = 0;
	for(i=0;i<TAM;i++){
		p.elems[i].cor = colorBrown; /*testar inicialziar*/
		p.elems[i].dir = 0;
	}

	while(true){
		ult = ultrassonico();
		cor = getColor(S2);

		if(cor == colorBlack){
			estado = SEM_SAIDA;
		}else{
			if(cor != colorWhite){
				anda_x_cm (5);
				displayText(line1,"estado interseccao");
				estado = INTERSECCAO;
				}else{
				estado = RETO;

			}
		}

		switch(estado){
		case INTERSECCAO:
			interseccao(p,cor);
			//imprime_pilha(p);
			break;
		case RETO:
			AndarReto(1);
			break;
		case SEM_SAIDA:
			semSaida();
			break;
		}

	}
}
